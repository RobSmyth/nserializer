#sidebar SideBarTableOfContets
With each new product version the format of the saved XML file may change. This can be due to changed namespaces or class names. Data migration is to allow an application to read a prior version's file and convert it to the current application objects. This is a work in progress, not all migration scenarios are supported.

=Supported Migration=

Currently NXmlSerializer supports migration with the following changes to application data types:

    * Namespace
    * Type name
    * New fields

Hopefully in future release:

    * Deleted fields
    * Field name
    * Split class
    * Merged classes (consolidation?)

Migration can be divided into either data movement (renaming, type splits/merging, deletion) or consolidation where data is processed to produce a new state. All of the above are the former.

=Types of Migration=

==Changed type and/or namespace names==

Currently supported.

Best practice is to pass a type name mapper object, implementing the interface IWriterTypeNameMapper, to the writer to use nicknames for type serialization. If this is done changes to namespace or type names are done automatically as only the nickname is used in the XML file.

However if the prior version did not use a type name mapper for the changed namespace or type a mapping type finder can be passed to the reader to pass current application types when the old type name is found. The code below shows a sample mapping type finder that will return the current type MyOldNamespaceName.MyOldClassName when the old name MyOldNamespaceName.MyOldClassName is found in the file.

{{{
public class SampleReaderMappingTypeFinder : IReaderMappingTypeFinder
{
    public bool CanHandle(string name)
    {
        return name == "MyOldNamespaceName.MyOldClassName"; // old name
    }
 
    public Type Get(string name)
    {
        return typeof(MyNamespace.MyClass);
    }
}
}}}

==New fields==

Currently supported.

NXmlSerializer deserializes types that have fields. The new fields with have null or default values.

==Changed field names==

Not supported. Work in progress.

Approach being considered: Use type aliasing to provide an inhereted class that implements the field with the original name. This would require an initialise method. NSerializer may support this more directly by recongnizing an interface to invoke the initialize method after deserializing.

==Type refactored to multiple types==

Not supported. Work in progress.

Issue to solve:

    * Resolve references to the correct type(s).
    * Redirect field values to new types.
    * Execute logic to initialise new types.


Approach being considered: Use type aliasing to provide a class that implements the original class's fields. Provide proxies for the new types. Reference mapping.

==Multiple types merged to another type==

Not supported. Work in progress.

For this migration to be possible will require either an implied association between the original types (scope) or an explicit relationship between the two original types (references).

Issue to solve:

    * Resolve scope.
    * Recognize relationship by references.


Probably an infrequent scenario so this will be a lower priority feature.

==Fields split/merged==

Now partially supported. Work in progress.

=Links=
 * [http://en.wikipedia.org/wiki/Data_conversion Data conversion]
 * [http://en.wikipedia.org/wiki/Data_transformation Data transformation]